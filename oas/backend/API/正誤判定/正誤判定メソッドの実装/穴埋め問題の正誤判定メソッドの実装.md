以下の条件を満たす、Service クラスを実装してください。
今回は、まず第一弾として、穴埋め問題（question_type: FILL_IN_THE_BLANK）の正誤判定を実装してください。

# 指示
1.
QuestionJson の　evaluation_spec.evaluation_method が CODE の場合は、予め用意してあるメソッドで正誤判定をしたいです。
正誤メソッドの名前は、App\Enums\EvaluationCheckerMethod で管理し、evaluation_spec.checker_method で指定します。
evaluation_spec.checker_method は、user_questions テーブルの、checker_method に保存されているのでそちらを使用してください。

2.
正誤メソッド は、今後も無数に増え続けることと、正誤判定（AnswerService） 以外でも使用しますので、
正誤判定用メソッドだけを集めた Service クラスを実装してください。
ネームスペースは、namespace App\Services\Utils　以下に作ってください

3.
1で実装した判定メソッドを、AnswerService で、evaluation_spec.evaluation_method が CODE の時に、
evaluation_spec.checker_method で指定されているメソッドで判定するように実装してください

4.
今回は、まず第一弾として、穴埋め問題（question_type: FILL_IN_THE_BLANK）の正誤判定を実装してください。
レスポンスは、user_questions.evaluation_response_format と同じ形式でレスポンスしてください。

判定方式は、
user の回答データは、metadata.input_format と同じ形式で｛#ユーザーが回答する時に送るJSON}がリクエストされます。
｛#問題JSONの全体構造} を見てもらうと、metadata.input_format.user_answer に、定義された型（例えば "number" とあれば 数値型）で値が入力されます。


ユーザーが回答する時に送るJSONの fields　の field_id と一致する、
evaluation_spec.response_format.fields（必ず user_questions から取得すること） の field_id を探し、その値の
evaluation_spec.response_format.fields.collect_answer　と、
ユーザーが回答する時に送るJSONの fields　の　user_answer　が一致すれば正答です。

5.
レスポンスは、evaluation_spec.response_format と同じ形式でレスポンスします。

is_correct: fields の値が全て正答だった場合は、true, そうでなければ false
score: 100 点を fields の数で割った値が１問辺りの点数で、正答数で計算して入力
question_text,explanation,question は、App::getLocale で現在設定されている言語設定を、user_questions から取得して入れる。
fields.user_answer は、field_id が一致するユーザーの回答
fields.is_correct は、field_id が一致するユーザーの回答が、collect_answerと一致すれば true
fields.user_answer は、field_id が一致するユーザーの回答
fields.field_explanation は、App::getLocale で現在設定されている言語設定を、evaluation_spec.response_format.fields.field_explanation　で定義されている文字列を入れる

6.
"check_method": "CALCULATE_METHOD",と指定されていますが、CALCULATE_METHOD は今回の実装の文脈には合わないので、
新しい　Enum の値を追加してください。
FILL_IN_THE_BLANKでも文字列ケースの評価とか色々想定されるので、値が完全に一致しているかを評価することが分かるメソッド名にしてください

7.
例えば、
$checkerEnum = EvaluationCheckerMethod::from("CALCULATE_METHOD");
switch ($checkerEnum) {
のような形式で、switch や if などで、条件分岐をすると、評価メソッドは今後数百以上数が増える可能性があり冗長になってしまうので、
なにか enum の値から呼び出しメソッドをコール出来るような工夫をしてほしい

8.
method が存在するかはちゃんとチェックするべき。エラーになる。

9.
Enum のキーはメソッド名と同じにしてください。
例えば、以下のように、キーは、CHECK_BY_EXACT_MATCH として
メソッド名は、checkByExactMatch　として、
大文字_大文字　という形式からキャメルケースに変換するような処理にするとどうだろうか。
文字列変換は、共通処理なので、CommonLib  に、「大文字_大文字　という形式からキャメルケースに変換する」処理ということが分かりやすいメソッド名で実装して共通化してほしい



※注意点
・現在は question_type FILL_IN_THE_BLANK の仕様だけですが、将来的に複数の種類が追加されて行く予定です。１００個以上になるかも

・エラーメッセージは多言語化が必要なので、その旨を日本語でTODOコメントとして残しておいてください

・後で分かりやすいようにソースコードのコメントには必ず実装の仕様をまとめて残しておくこと

・コードは Testable に記述すること。密結合しないように実装してください

・QuestionJson の仕様は、QuestionJsonManageService を参考にしてください


ーー言語定数
ja, en


-- input_format.fields.type、evaluation_spec.response_format.fields.user_answer,metadata.input_format.fields.user_answer の定数
number: 数値型

-- input_format.question_components.type定数
text: テキスト
image: 画像
movie: 動画
blank: 空欄。入力項目

ーーJSON仕様
order：必須、数値
id：必須、文字列
level_id：必須、文字列、Levels テーブルのjson_idに一致する値があること
grade_id：必須、文字列、Grade テーブルのjson_idに一致する値があること
difficulty_id：必須、文字列、Difficulties テーブルのjson_idに一致する値があること
version： 必須、文字列、文字列が x.x.x のようなバージョニング形式になっているか
status：必須、QuestionStatus に値が存在しているか
generated_by_llm：必須、Boolean
created_at：必須、Y-m-d H:i:s 形式になっていること
updated_at：必須、Y-m-d H:i:s 形式になっていること

skills: 必須、配列
skills.skill_id: 必須、Skills テーブルのjson_idに一致する値があること
skills.name: 必須、文字列、skill_id と一致するSkills テーブルのjson_idを持つデータの　display_name と値が一致すること

learning_requirements:必須、オブジェクト
learning_requirements.learning_subject: 必須、文字列
learning_requirements.learning_no: 必須、数値型
learning_requirements.learning_requirement: 必須、文字列
learning_requirements.learning_required_competency: 必須、文字列
learning_requirements.learning_background: 必須、文字列
learning_requirements.learning_category: 必須、文字列
learning_requirements.learning_grade_level: 必須、文字列
learning_requirements.learning_url: 必須ではない、文字列、URL

evaluation_spec：必須、オブジェクト
evaluation_spec.evaluation_method: 必須、文字列、EvaluationMethod　に値が存在していること
evaluation_spec.checker_method: evaluation_methodが”CODE”の時は必須、文字列型、EvaluationCheckerMethod　に値が存在していること
evaluation_spec.llm_prompt_number: evaluation_methodが”LLM”の時は必須、数値。LLMに投げるプロンプトを管理するファイルと対応している。resources/prompts/evaluation/{x}.txt の {x}の箇所と対応しているので、このファイルが存在しているかバリデーションチェックする。
evaluation_spec.response_format：必須、オブジェクト。LLMに正誤判定を依頼する時に指定するレスポンスの形や、CheckerMethod での正誤判定時のレスポンスに利用する
evaluation_spec.response_format.is_correct：必須、テキスト型("boolean"のみ）。回答全体が正解かどうか表す
evaluation_spec.response_format.score：必須、テキスト型("number"のみ）。スコアを表す
evaluation_spec.response_format.question_text：必須、オブジェクト（言語定数全て含んでいるか）, evaluation_methodが”LLM”の時は、言語ごとにそれぞれ オブジェクトの中の値は "{$言語設定例えば"ja"など}": "text"となっていること。evaluation_methodが”CODE”の時は、言語ごとにそれぞれ question_text と全く同じ値が含まれていること
evaluation_spec.response_format.explanation：必須、オブジェクト（言語定数全て含んでいるか）, evaluation_methodが”LLM”の時は、言語ごとにそれぞれ オブジェクトの中の値は "{$言語設定例えば"ja"など}": "text"となっていること。evaluation_methodが”CODE”の時は、言語ごとにそれぞれ オブジェクトの中の値は "{$言語設定例えば"ja"など}": に問題文となる文字列が含まれていること
evaluation_spec.response_format.question：必須、オブジェクト（言語定数全て含んでいるか）、言語ごとにそれぞれ オブジェクトの中の値は "{$言語設定例えば"ja"など}": "text"となっていること。evaluation_methodが”CODE”の時は、言語ごとにそれぞれ metadata.question と全く同じ値が含まれていること

evaluation_spec.response_format.fields：evaluation_methodが”LLM”の時は必須、配列。LLMにユーザーの回答の形を知らせる為にフォーマットを定義。
evaluation_spec.response_format.fields.field_id：必須、配列。ユーザーの回答の型。
evaluation_spec.response_format.fields.user_answer：必須、input_format.fields.type、evaluation_spec.response_format.fields.user_answer,evaluation_spec.input_format.fields.collect_answer の定数に値があるか。ユーザーの回答。
evaluation_spec.response_format.fields.is_correct：必須、テキスト型("boolean"のみ）。ユーザーの回答が正しいか
evaluation_spec.response_format.fields.collect_answer：必須、evaluation_spec.response_format.fields.user_answerで指定されている型と一致しているか。例えば、"number" の場合は、32 などの数値となっているか。問題の正解（ユーザーには隠す）
evaluation_spec.response_format.fields.field_explanation: 必須、オブジェクト、言語ごとにそれぞれ オブジェクトの中の値は "{$言語設定例えば"ja"など}": "文字列"が含まれていること。空文字禁止

metadata.question_type：必須、App\Enums\QuestionType.php に値が存在しているか。JSONには、文字列でも数値でもどちらでも入力可にする

metadata.question_text: 必須、オブジェクト（言語定数全て含んでいるか）
metadata.explanation: 必須、オブジェクト（言語定数全て含んでいるか）
metadata.background: 必須、オブジェクト（言語定数全て含んでいるか）
metadata.question ：必須、オブジェクト（言語定数全て含んでいるか）。問題文

metadata.input_format: 必須、オブジェクト（言語定数全て含んでいるか）
metadata.input_format.fields: 必須、配列。ユーザが回答する入力フォームの仕様を定義
metadata.input_format.fields.field_id: 必須、f_x のフォーマットになっているか。同じ fields 内に重複した値が存在しないか。 question_components内の type: "blank"の数と総数が合っているか。
metadata.input_format.fields.attribute: 必須、（input_format.fields.type、evaluation_spec.response_format.fields.user_answer,evaluation_spec.response_format.fields.collect_answer の定数に値が存在しているか）。ブランクのフォームの属性。例えば number であれば、<input type="number">になる
metadata.input_format.fields.user_answer: 必須、次の条件を満たした文字列型かどうかをチェックする。input_format.fields.type、evaluation_spec.response_format.fields.user_answer,evaluation_spec.response_format.fields.collect_answer の定数に値があるか。ユーザーが入力する正答の型。

metadata.input_format.question_components: 必須（問題を更生する要素）
metadata.input_format.question_components.attribute：必須、input_format.question_components.type定数と値が合っているか
metadata.input_format.question_components.content：必須、オブジェクト、言語定数と一致する値が全て含まれているか
metadata.input_format.question_components.order: 必須、数値、重複する値が存在しないこと。問題を構築するときの表示順番

--- ユーザーが回答する時に送るJSON
```json
{
  "fields": [
    {
      "field_id": "f_1",
      "attribute": "number",
      "user_answer": 4
    },
    {
      "field_id": "f_2",
      "attribute": "number",
      "user_answer": 32
    }
  ]
}

```

--- 問題JSONの全体構造
```json
{
  "order": 100,
  "id": "ques_s1_g2_sec800_u100_diff100_qt51_v100_100",
  "level_id": "lev_002",
  "grade_id": "gra_002",
  "difficulty_id": "diff_100",
  "version": "1.0.0",
  "status": "PUBLISHED",
  "generated_by_llm": true,
  "created_at": "2025-01-01 00:00:00",
  "updated_at": "2025-01-01 00:00:00",
  "skills": [
    {
      "skill_id": "sk_004",
      "name": "知識・技能"
    }
  ],
  "learning_requirements": [
    {
      "learning_subject": "算数",
      "learning_no": 22,
      "learning_requirement": "計算の意味・方法 計算の決まり 加法の交換法則を式で示す",
      "learning_required_competency": "a + b = b + a を具体例（3+5=5+3等）で理解し，同じ結果になることを確認できる",
      "learning_background": "実際に小物を数える・ブロックを移し替えるなど操作的活動と組み合わせると，法則への納得感が高まる。後の乗法の交換法則にも発展しやすい",
      "learning_category": "A",
      "learning_grade_level": "小2",
      "learning_url": ""
    }
  ],
  "evaluation_spec": {
    "evaluation_method": "CODE",
    "check_method": "CALCULATE_METHOD",
    "llm_prompt_number": 1,
    "response_format": {
      "is_correct": "boolean",
      "score": "number",
      "question_text": {
        "ja": "text",
        "en": "text"
      },
      "explanation": {
        "ja": "text",
        "en": "text"
      },
      "question": {
        "ja": "text",
        "en": "text"
      },
      "fields": [
        {
          "field_id": "f_1",
          "user_answer": "number",
          "is_correct": "boolean",
          "collect_answer": 3,
          "field_explanation": {
            "ja": "3 + 5 の順序を入れ替えると 5 + 3 なので、ブランクには 3 が入ります。",
            "en": "When swapping the order of 3 + 5, we get 5 + 3, so 3 fits in the blank."
          }
        },
        {
          "field_id": "f_2",
          "user_answer": "number",
          "is_correct": "boolean",
          "collect_answer": 8,
          "field_explanation": {
            "ja": "3 + 5 と 5 + 3 は同じ答えで 8 です。",
            "en": "Both 3 + 5 and 5 + 3 result in 8."
          }
        }
      ]
    }
  },
  "metadata": {
    "question_type": "FILL_IN_THE_BLANK",
    "question": {
      "ja": "3 + 5 = 5 + ▢ = ▢",
      "en": "3 + 5 = 5 + ▢ = ▢"
    },
    "question_text": {
      "ja": "▢にあてはまる数を答えなさい。",
      "en": "Please answer the numbers that fit in the blanks."
    },
    "explanation": {
      "ja": "加法の交換法則という考え方を使うと、3 + 5 の答えと、5 + 3 の答えは同じになります。今回は、どちらの順番で足しても同じ合計になることを確かめましょう。",
      "en": "Using the commutative property of addition, 3 + 5 and 5 + 3 give the same result. In this problem, you will check that the total is the same no matter the order."
    },
    "background": {
      "ja": "この問題では、加法（足し算）の交換法則「a + b = b + a」を学習します。小学生2年生の段階で、足し算は順番を変えても同じ答えになることを具体的に体験してもらうための問題です。",
      "en": "This problem focuses on the commutative property of addition, showing that a + b = b + a. It is designed for second-graders to experience that switching the order in addition yields the same result."
    },
    "input_format": {
      "type": "fixed",
      "fields": [
        {
          "field_id": "f_1",
          "attribute": "number",
          "user_answer": "number"
        },
        {
          "field_id": "f_2",
          "attribute": "number",
          "user_answer": "number"
        }
      ],
      "question_components": [
        {
          "type": "text",
          "content": {
            "ja": "3 + 5 = 5 + ",
            "en": "3 + 5 = 5 + "
          },
          "order": 1
        },
        {
          "type": "blank",
          "field_id": "f_1",
          "order": 2
        },
        {
          "type": "text",
          "content": {
            "ja": " = ",
            "en": " = "
          },
          "order": 3
        },
        {
          "type": "blank",
          "field_id": "f_2",
          "order": 4
        }
      ]
    }
  }
}

```



# 実装方針
生成また修正変更するコードはそのコードだけは必ず省略せずに必ず全てアウトプットすること。
仕様はソースコードにまとめてコメントとして残すこと

ビジネスロジックは Model へ、
ビジネスロジックへのアクセスは service を介して行うこと。

アーキテクチャ構成は
- **アーキテクチャ構成(クリーンアーキテクチャ)**：
    - - **Model**
        - ビジネスロジックを記述
    - **Controller**
        - リクエストを受け取り、適切なUseCaseを呼び出します。
    - **UseCase**
        - 特定のユースケース（機能）に対するビジネスロジックを実装し、必要なServiceを利用して処理を行います。
    - **Service**
        - データアクセスや共通のビジネスロジックを実装します。データの取得や保存を担当し、Modelと連携します。
    - **DTO（Data Transfer Object）**
        - レイヤー間でデータを転送するためのオブジェクトで、データの構造を明示的に定義します。
    - **Resource**
        - APIレスポンスはResourceで定義する
          のように実装してください。


# 説明
question_sets：問題（questions）を束ねるグループ
questions: 問題
question_set_questions：question_sets と questions を紐づけるPivotテーブル。questions は複数のquestion_sets に紐づく事があり多対多の関係なのでこのような設計になっている。
user_question_sets: ユーザーが学習した questions_sets。学習開始時に question_sets_id と紐づいて status （UserQuestionSetsStatus::NOT_START) が未開始の状態で生成され、進捗ステータスはスコアなどが管理される
user_questions: ユーザーが学習した questions。学習開始時に、学習を開始した question_sets に紐づく questions が全て、 user_question_sets_id と question_id（questions）を紐づけて status （UserQuestionStatus::NOT_START) が未開始の状態で全てのquestionsの数の分、生成され、進捗ステータスはスコアなどが管理される

# ディレクトリ構成
masamo-server
├── app
│   ├── Console
│   │   └── Commands
│   ├── Dtos
│   ├── Enums
│   ├── Http
│   │   ├── Controllers
│   │   ├── Middleware
│   │   ├── Requests
│   │   └── Resources
│   ├── Models
│   ├── Providers
│   ├── Services
│   ├── Traits
│   └── UseCases
├── bootstrap
├── config
├── database
│   ├── factories
│   ├── migrations
│   ├── seeders
│   ├── .gitignore
│   └── database.sqlite
├── docs
├── lang
│   ├── en
│   └── ja
├── public
├── resources
│   ├── css
│   ├── js
│   ├── prompts
│   └── views
├── routes
├── storage
├── tests
└── vendor

--- DB構造
```php


```

--- EvaluationCheckerMethod Enum
```php
<?php

namespace App\Enums;

// 問題の正誤を評価するメソッドをマップしたEnum
enum EvaluationCheckerMethod: int
{
    case CALCULATE_METHOD = 1;

    public function label(): string
    {
        return match($this) {
            self::CALCULATE_METHOD          => 'CALCULATE_METHOD',
        };
    }

    /**
     * 文字列から EvaluationCheckerMethod を取得
     * @param string $statusString 例: "CALCULATE_METHOD" など
     * @return self
     */
    public static function fromString(string $statusString): self
    {
        return match (strtoupper($statusString)) {
            'CALCULATE_METHOD'          => self::CALCULATE_METHOD,
            default => throw new \InvalidArgumentException("Unknown status string: {$statusString}")
        };
    }
}

```


--- QuestionType Enum
```php
<?php

namespace App\Enums;

// 問題のカテゴリ（出題形式とは別）
enum QuestionType: int
{
    case CALCULATION             = 1;
    case FILL_IN_THE_BLANK       = 51;
    case SCENARIO                = 101;
    case MULTIPLE_CHOICE         = 151;

//    case SIMPLE_ARITHMETIC        = 10;
//    case COMBINATION             = 101;
//    case HELL                    = 151;
//    case STORY                   = 201;
//    case FREE_TEXT               = 251;
//    case DRILL                   = 301;
//    case SIMULATION              = 401;
//    case DEBUG                   = 451;
//    case PROOF                   = 501;
//    case REASONING               = 551;
//    case MULTI_STEP_COMPARATIVE  = 601;
//    case FUSION                  = 651;
//    case INFERENCE               = 701;
//    case DATA_INTERPRETATION     = 751;
//    case LOGIC                   = 801;

    public function label(): string
    {
        return match($this) {
            self::CALCULATION            => 'Calculation Problem',              // 計算問題: 数値計算や演算ルールの処理を中心
            self::FILL_IN_THE_BLANK      => 'Fill-in-the-Blank Problem',        // 穴埋め問題: 問題文や式に空所があり、そこを埋める形式
            self::SCENARIO               => 'Scenario Problem',                 // シナリオ問題: 状況や経過を踏まえて解決する（回答が一意じゃない）
            self::MULTIPLE_CHOICE        => 'Multiple Choice Problem',          // 選択問題: 複数の選択肢から答えを選ぶ

//            self::SIMPLE_ARITHMETIC      => 'Simple Arithmetic Problem',        // 単純計算問題: 簡単な計算式や数値操作を問う
//            self::COMBINATION            => 'Combination Problem',              // 組み合わせ問題: 対応するペアやグループをマッチさせる
//            self::HELL                   => 'Hell Problem',                     // 地獄問題: 選択肢が多く1つだけ正解がある特許取得済の問題
//            self::STORY                  => 'Story Problem',                    // ストーリー問題: 物語やシナリオで流れを理解しながら解答
//            self::FREE_TEXT              => 'Free Text Problem',                // フリーテキスト問題: 自由記述形式での回答
//            self::DRILL                  => 'Drill Problem',                    // 発生練習問題: 何かを生成・作成したりする練習を含む
//            self::SIMULATION             => 'Simulation Problem (Real-life Modeling)', // シミュレーション問題: 実生活モデルを扱う
//            self::DEBUG                  => 'Debug Problem',                    // デバッグ問題: ミスを発見し修正する
//            self::PROOF                  => 'Proof Problem',                    // 証明問題: 定理や結論がなぜ成り立つかを示す
//            self::REASONING              => 'Reasoning Problem',                // 理由づけ問題: 結果の根拠や理由を説明
//            self::MULTI_STEP_COMPARATIVE => 'Multi-Step Comparative Problem',   // 複数手順を比較検討する問題
//            self::FUSION                 => 'Fusion Problem',                   // 融合問題: 複数領域を組み合わせて解決
//            self::INFERENCE              => 'Inference Problem',                // 推理問題: 与えられた情報から論理的に結論を導く
//            self::DATA_INTERPRETATION    => 'Data Interpretation Problem',      // 統計資料の読み取り問題: グラフや表を使う
//            self::LOGIC                  => 'Logic Problem',                    // ロジック問題: プログラム的思考やアルゴリズム判断
        };
    }

    /**
     * 文字列を受け取り、該当する QuestionType を返す静的メソッド
     * 存在しない場合は例外を投げるサンプルです
     *
     * @param string $typeString "FILL_IN_THE_BLANK" など
     * @return QuestionType
     */
    public static function fromString(string $typeString): QuestionType
    {
        return match($typeString) {
            'CALCULATION'       => self::CALCULATION,
            'FILL_IN_THE_BLANK' => self::FILL_IN_THE_BLANK,
            'SCENARIO'          => self::SCENARIO,
            'MULTIPLE_CHOICE'   => self::MULTIPLE_CHOICE,
            default => throw new \InvalidArgumentException("Unknown QuestionType string: {$typeString}")
        };
    }
}
```
--- 関連するモデル
```php
<?php

namespace App\Models\User;

use App\Models\BaseModel;
use App\Models\Question\Question;
use App\Traits\UsesUuid;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

/**
 *
 *
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion newModelQuery()
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion newQuery()
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion onlyTrashed()
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion query()
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion withTrashed()
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion withoutTrashed()
 * @property string $id
 * @property string $user_question_set_id
 * @property string $question_id
 * @property int $status
 * @property string|null $answer_data
 * @property string|null $answered_at
 * @property \Illuminate\Support\Carbon|null $created_at
 * @property \Illuminate\Support\Carbon|null $updated_at
 * @property \Illuminate\Support\Carbon|null $deleted_at
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereAnswerData($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereAnsweredAt($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereCreatedAt($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereDeletedAt($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereId($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereQuestionId($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereStatus($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereUpdatedAt($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereUserQuestionSetId($value)
 * @property-read Question|null $question
 * @property-read \App\Models\User\UserQuestionSet|null $userQuestionSet
 * @property string|null $metadata
 * @property string $version
 * @property int $evaluation_method
 * @property int|null $checker_method
 * @property int|null $llm_evaluation_prompt_number
 * @property string|null $evaluation_response_format
 * @property int $question_type
 * @property string|null $learning_requirement_json
 * @property string|null $learning_subject 科目 (学習要件)
 * @property int|null $learning_no 学習要件の番号
 * @property string|null $learning_requirement 学習要件の内容
 * @property string|null $learning_required_competency 必要水準
 * @property string|null $learning_background 背景・補足
 * @property string|null $learning_category 分類
 * @property string|null $learning_grade_level 学年
 * @property string|null $learning_url URLリンク
 * @property int $generated_by_llm
 * @property int $order
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereCheckerMethod($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereEvaluationMethod($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereGeneratedByLlm($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLearningBackground($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLearningCategory($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLearningGradeLevel($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLearningNo($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLearningRequiredCompetency($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLearningRequirement($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLearningRequirementJson($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLearningSubject($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLearningUrl($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLlmEvaluationPromptNumber($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereLlmEvaluationResponseFormat($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereMetadata($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereOrder($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereQuestionType($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereVersion($value)
 * @property string|null $prompt_for_evaluation
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion wherePromptForEvaluation($value)
 * @method static \Illuminate\Database\Eloquent\Builder<static>|UserQuestion whereEvaluationResponseFormat($value)
 * @mixin \Eloquent
 */
class UserQuestion extends BaseModel
{
    use UsesUuid, SoftDeletes;

    // 主キーがUUIDであることを指定
    protected $keyType = 'string';
    public $incrementing = false;

    protected $with = [
        'translations',
    ];


    /*=====================================================
     * リレーション
     *=====================================================*/
    public function userQuestionSet()
    {
        return $this->belongsTo(UserQuestionSet::class, 'user_question_set_id');
    }

    public function question()
    {
        return $this->belongsTo(Question::class, 'question_id');
    }

    /**
     * 翻訳テーブルとのリレーション
     */
    public function translations()
    {
        return $this->hasMany(UserQuestionTranslation::class, 'user_question_id');
    }


    /*=====================================================
    * カスタムメソッド/Custom Method
    *=====================================================*/

    /**
     * 現在のlocaleに応じた翻訳を返す
     * なければfallback_localeの翻訳を返す
     */
    public function getTranslation(?string $locale = null): ?UserQuestionTranslation
    {
        $locale = $locale ?: app()->getLocale();
        return $this->translations->firstWhere('locale', $locale)
            ?: $this->translations->firstWhere('locale', config('app.fallback_locale'));
    }
}

<?php

namespace App\Models\User;

use App\Models\BaseModel;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class UserQuestionTranslation extends BaseModel
{
    use SoftDeletes, HasFactory;

    protected $fillable = [
        'user_question_id',
        'locale',
        'question_text',
        'explanation',
        'background',
    ];

    public function userQuestion()
    {
        return $this->belongsTo(UserQuestion::class, 'user_question_id');
    }
}

```

---関連するmigration
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('user_questions', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('user_question_set_id');
            $table->uuid('question_id');

            $table->json('metadata')->nullable();
            $table->string('version')->default('0.0.1');
            $table->integer('evaluation_method')->default(1);
            $table->integer('checker_method')->nullable();
            $table->integer('llm_evaluation_prompt_number')->nullable();
            $table->json('evaluation_response_format')->nullable();
            $table->integer('question_type')->default(1);
            $table->json('learning_requirement_json')->nullable();
            $table->string('learning_subject')->nullable()
                ->comment('科目 (学習要件)');
            $table->integer('learning_no')->nullable()
                ->comment('学習要件の番号');
            $table->text('learning_requirement')->nullable()
                ->comment('学習要件の内容');
            $table->text('learning_required_competency')->nullable()
                ->comment('必要水準');
            $table->text('learning_background')->nullable()
                ->comment('背景・補足');
            $table->string('learning_category')->nullable()
                ->comment('分類');
            $table->string('learning_grade_level')->nullable()
                ->comment('学年');
            $table->string('learning_url')->nullable()
                ->comment('URLリンク');
            $table->boolean('generated_by_llm')->default(false);

            $table->integer('status')->default(1);
            $table->json('answer_data')->nullable();
            $table->longText('prompt_for_evaluation')->nullable();
            $table->timestamp('answered_at')->nullable();
            $table->integer('order');
            $table->timestamps();
            $table->softDeletes();

            $table->foreign('user_question_set_id')->references('id')->on('user_question_sets')->onDelete('cascade');
            $table->foreign('question_id')->references('id')->on('questions')->onDelete('cascade');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('user_questions');
    }
};
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('user_question_translations', function (Blueprint $table) {
            $table->id();
            $table->uuid('user_question_id');
            $table->string('locale', 10);
            $table->longText('question_text')->nullable();
            $table->longText('explanation')->nullable();
            $table->longText('background')->nullable();
            $table->timestamps();
            $table->softDeletes();

            $table->foreign('user_question_id')->references('id')->on('user_questions')->onDelete('cascade');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('user_question_translations');
    }
};


```
--- CommonLib
```php
<?php

namespace App\Helpers;

use App\Enums\PlatformType;
use App\Enums\UserAgentKeyword;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\Request;

class CommonLib
{


    /**
     * キャメルケース -> スネークケース
     *
     * @param string $str
     * @return string
     */
    public static function convSnakeCase($str)
    {
        return ltrim(strtolower(preg_replace('/[A-Z]/', '_\0', $str)), '_');
    }

    /**
     * スネークケース -> キャメルケース
     *
     * @param string $str
     * @return string
     */
    public static function convCamelCase($str)
    {
        return lcfirst(strtr(ucwords(strtr($str, ['_' => ' '])), [' ' => '']));
    }

    /**
     * 桁数指定のランダムパスワード生成
     *
     * @param int $n
     * @return string
     */
    public static function createRandomPassword(int $n)
    {
        return strtr(substr(base64_encode(openssl_random_pseudo_bytes($n)), 0, $n), '/+', '_-');
    }

    /**
     * 文字列から郵便番号部分を取り除く
     *
     * @param string $string
     * @return string
     */
    public static function removalZipStr(string $string)
    {
        $match_count = preg_match("/^(〒[-\d]+)?(\s+)?(.+)$/", $string, $matches);
        if ($match_count > 0) {
            $string = $matches[3];
        }
        return $string;
    }

    /**
     * 非同期バッチ(laravelのartisanだと同期してしまう)
     *
     * @param string $nameCommand
     * @param array $params
     * @return void
     */
    public static function exeBatch(string $nameCommand, array $params = [])
    {
        $param = '';
        if ($params) {
            $param = join(" ", $params);
        }
        exec(sprintf("/usr/bin/php %s/artisan %s %s > /dev/null &", base_path(), $nameCommand, $param));
    }

    /**
     * 画像パス
     *
     * @param string $type
     * @param int $id
     * @param string $path
     * @return string
     */
    public static function getFullPathImg(string $type, int $id, string $path = null)
    {
        $httpProtocol = config()->get('app.env') != 'production' ? 'http' : 'https';

        return sprintf('%s://%s/%s/%s/%s', $httpProtocol, config('app.app_static_domain'), $type, $id, urlencode(urlencode($path)));
    }

    /**
     * ユーザーエージェントを解析して、使用中のプラットフォームの種類を返します。
     *
     * @return string 使用中のプラットフォームの種類
     */
    public static function getPlatformFromUserAgent(): string
    {
        $user_agent = request()->header('User-Agent');

        // デバイスの種類に基づく判定
        // Native アプリ Android
        if (self::containsAny($user_agent, [UserAgentKeyword::NativeAndroid])) {
            return PlatformType::NativeAndroid->value;
        }
        // Native アプリ iOS
        if (self::containsAny($user_agent, [UserAgentKeyword::NativeIOS])) {
            return PlatformType::NativeIOS->value;
        }
        // ブラウザ iOS
        if (self::containsAny($user_agent, [UserAgentKeyword::iPhone, UserAgentKeyword::iPod, UserAgentKeyword::iOS])) {
            return PlatformType::iOS->value;
        }
        // ブラウザ iPad OS
        if (self::containsAny($user_agent, [UserAgentKeyword::iPad])) {
            return PlatformType::iPadOS->value;
        }
        // ブラウザ Android
        if (self::containsAny($user_agent, [UserAgentKeyword::Android])) {
            return PlatformType::Android->value;
        }
        // ブラウザ Windows Phone
        if (self::containsAny($user_agent, [UserAgentKeyword::WindowsPhone])) {
            return PlatformType::WindowsPhone->value;
        }

        // それ以外の場合は一般的なブラウザとして扱う
        return PlatformType::Browser->value;
    }

    /**
     * 指定されたユーザーエージェント文字列が、いずれかのキーワードを含むかどうかをチェックします。大文字小文字は区別しません。
     *
     * @param string $userAgent ユーザーエージェント文字列
     * @param array $keywords チェックするキーワードの配列
     * @return bool
     */
    public static function containsAny(string $userAgent, array $keywords): bool
    {
        foreach ($keywords as $keyword) {
            if (stripos($userAgent, $keyword->value) !== false) {
                return true;
            }
        }

        return false;
    }

    /**
     * ランダムなパスワードを生成する
     *
     * @param int $length
     * @return bool|string
     */
    public static function randomPass($length = 8)
    {
        return substr(str_shuffle('1234567890abcdefghijklmnopqrstuvwxyz'), 0, $length);
    }

    /**
     * ID を元に戻す
     */
    public static function restoreId($id): int
    {
        return (int)str_replace(config()->get('api.response_salt'), '', base64_decode($id));
    }

    /**
     * @param $request Request
     * @return array
     * セキュリティ関連情報マスク用
     */
    public static function protectedParams($request)
    {
        $protected = [];
        foreach ($request->all() as $key => $value) {
            $protected[$key] = in_array($key, config('const.parameter_black_list'), true) ? "████" : $value;
        }
        return $protected;
    }

    /**
     * "CHECK_BY_EXACT_MATCH" → "checkByExactMatch"
     * @param string $uppercaseSnake e.g. "CHECK_BY_EXACT_MATCH"
     * @return string
     */
    public static function snakeUpperToCamel(string $uppercaseSnake): string
    {
        // 大文字_大文字 を小文字にして _ で explode
        $parts = explode('_', strtolower($uppercaseSnake));
        // 先頭はそのまま、2つ目以降を先頭大文字に
        $parts = array_map(fn($part, $idx) => $idx === 0
            ? $part
            : ucfirst($part),
            $parts,
            array_keys($parts)
        );
        return implode('', $parts);
    }
}

```

--- EvaluationMethod Enum
```php
<?php

namespace App\Enums;

// 問題の正誤を評価するメソッドをマップしたEnum
use App\Helpers\CommonLib;

enum EvaluationCheckerMethod: int
{
    case CALCULATE_METHOD = 10;
    case CHECK_BY_EXACT_MATCH = 50;

    public function label(): string
    {
        return match($this) {
            self::CALCULATE_METHOD          => 'CALCULATE_METHOD',
            self::CHECK_BY_EXACT_MATCH          => 'CHECK_BY_EXACT_MATCH',
        };
    }

    /**
     * 文字列から EvaluationCheckerMethod を取得
     * @param string $statusString 例: "CALCULATE_METHOD" など
     * @return self
     */
    public static function fromString(string $statusString): self
    {
        return match (strtoupper($statusString)) {
            'CALCULATE_METHOD'          => self::CALCULATE_METHOD,
            'CHECK_BY_EXACT_MATCH'          => self::CHECK_BY_EXACT_MATCH,
            default => throw new \InvalidArgumentException("Unknown status string: {$statusString}")
        };
    }


    /**
     * このEnumのキーをキャメルケースに変換して、Serviceクラスのメソッド名として使う
     * 例: "CHECK_BY_EXACT_MATCH" → "checkByExactMatch"
     */
    public function methodName(): string
    {
        return CommonLib::snakeUpperToCamel($this->label());
    }
}


```

＝＝＝ 正誤判定（AnswerService.php）
```php
<?php

namespace App\Services\V1\Answer;

use App\Dtos\V1\Answer\AnswerCheckDto;
use App\Enums\EvaluationMethod;
use App\Enums\UserQuestionSetStatus;
use App\Enums\UserQuestionStatus;
use App\Models\Question\Question;
use App\Models\User\UserQuestion;
use App\Models\User\UserQuestionSet;
use App\Services\Utils\Question\QuestionJsonManageService;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Http;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Illuminate\Validation\ValidationException;

class AnswerService
{
    private QuestionJsonManageService $questionJsonManageService;

    public function __construct(QuestionJsonManageService $questionJsonManageService)
    {
        $this->questionJsonManageService = $questionJsonManageService;
    }

    // TODO 回答メソッド指定への対応。例えば計算とか
    /**
     * (1) user_question_id & answer_data を受け取り
     * (2) question.evaluation_method で LLM or CODE 判定
     * (3) user_questions に正誤・回答日時を保存
     * (4) 次の問題を探して返却 / なければ user_question_sets を COMPLETE
     * (5) 返却用に AnswerCheckDto を組み立てる
     */
    public function evaluateAnswer(string $userId, string $userQuestionId, string $answerDataJson): AnswerCheckDto
    {
        // user_questions と user_question_sets を確認
        // user_questions を取得し、ユーザーが所有するレコードかチェック
        $userQuestion = UserQuestion::where('id', $userQuestionId)->first();
        if (!$userQuestion) {
            // 多言語化対応した例
            throw new NotFoundHttpException(
                __("errors.api.answer.user_question_not_found", ['id' => $userQuestionId])
            );
        }

        // user_question_sets
        $userQuestionSet = UserQuestionSet::where('id', $userQuestion->user_question_set_id)->first();
        if (!$userQuestionSet) {
            throw new NotFoundHttpException(
                __("errors.api.answer.user_question_set_not_found", ['id' => $userQuestion->user_question_set_id])
            );
        }

        // user_id が一致するか
        if ($userQuestionSet->user_id !== $userId) {
            throw new NotFoundHttpException(
                __("errors.api.answer.user_question_not_found", ['id' => $userQuestionId])
            );
        }

        // question を取得し、evaluation_method 分岐
        $question = Question::find($userQuestion->question_id);
        if (!$question) {
            throw new NotFoundHttpException(
                __("errors.api.answer.question_not_found", ['id' => $userQuestion->question_id])
            );
        }

        // user_questions.metadata から input_format 情報を取得し、
        //   QuestionJsonManageService に回答JSONを動的チェックさせる
        //   （将来的に question_type 別のロジック増を想定）
        $metadataArr = json_decode($userQuestion->metadata, true);
        if (!is_array($metadataArr)) {
            // 多言語化対応TODO: エラーメッセージ
            throw ValidationException::withMessages(["metadata" => "user_questionのmetadataが不正です。"]);
        }

        // parse string → array (万が一stringのケースがあれば)
        // もし $userQuestion->metadata がjsonencodeされたstringなら decode
        // $metadata = is_string($metadataJson) ? json_decode($metadataJson,true) : $metadataJson;
        // ここでは $metadataJson が array 前提とする
        $metadata = $metadataArr; 

        // ユーザー回答を decode
        $answerArr = json_decode($answerDataJson, true);
        if (!is_array($answerArr)) {
            // 多言語化対応TODO: エラーメッセージ
            throw ValidationException::withMessages([
                'answer_data' => "回答JSONの形式が不正です。"
            ]);
        }

        // バリデーションチェック
        $this->questionJsonManageService->validateUserAnswer($answerArr, $metadata);

        $answeredAt = Carbon::now();

        // DB更新処理
        DB::beginTransaction();
        try {
            if ($question->evaluation_method == EvaluationMethod::LLM->value) {
                // LLM 評価
                $llmResult = $this->callLLMEvaluationApi($answerArr, $question, $userQuestion);

                // LLMが返す JSONの中で "fields" の is_correct が true なら正解とする簡易例
                $fields = data_get($llmResult, 'fields', []);
                $isAnyCorrect = false;
                foreach ($fields as $field) {
                    // "true" 文字列か boolean か不定なので緩く判定
                    if (data_get($field, 'is_correct') === true || data_get($field, 'is_collect') === "true") {
                        $isAnyCorrect = true;
                        break;
                    }
                }
                $status = $isAnyCorrect
                    ? UserQuestionStatus::CORRECT->value
                    : UserQuestionStatus::INCORRECT->value;

                // answer_data に LLM の出力を保存したいなら、$llmResult を保存する
                $saveAnswerData = $llmResult;
            } else {
                // CODE 評価
                $isCorrect = $this->evaluateByCode($question, $answerArr);
                $status = $isCorrect
                    ? UserQuestionStatus::CORRECT->value
                    : UserQuestionStatus::INCORRECT->value;

                // answer_data はユーザー入力データをそのまま保存
                $saveAnswerData = $answerArr;
            }

            // 回答時間などは更新しない。ステータスが場合は無視。
            if ($userQuestion->status != UserQuestionSetStatus::COMPLETE->value) {
                // user_questions に保存
                $userQuestion->status      = $status;
                $userQuestion->answered_at = $answeredAt;
                $userQuestion->answer_data = $saveAnswerData; // JSON
            }
            $userQuestion->save();

            // 次の問題を探す
            $nextUserQuestion = $this->findNextQuestion($userQuestionSet->id);
            // 回答時間などは更新しない。ステータスが進行中じゃない場合は無視。
            if (!$nextUserQuestion && $userQuestionSet->status == UserQuestionSetStatus::PROGRESS->value) {
                // もう問題がなければ user_question_sets を COMPLETE に
                $userQuestionSet->status = UserQuestionSetStatus::COMPLETE->value;
                $userQuestionSet->finished_at = Carbon::now();
                $userQuestionSet->save();
            }

            DB::commit();

            return $this->buildAnswerCheckDto(
                userQuestion: $userQuestion,
                question:     $question,
                nextUserQuestion: $nextUserQuestion,
                content: $saveAnswerData
            );
        } catch (\Throwable $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * (1) JSONパース
     * (2) 必要なキー (fields, question など) が存在するか
     */
    private function parseAndValidateAnswerData(string $answerDataJson): array
    {
        // JSON パース
        $parsed = json_decode($answerDataJson, true);

        if (! is_array($parsed)) {
            // JSONデコード失敗, or オブジェクトでない
            throw ValidationException::withMessages([
                'answer_data' => __("errors.api.answer.invalid_json_format"),
            ]);
        }

        // 必須キーがあるか
        if (empty($parsed['question'])) {
            throw ValidationException::withMessages([
                'answer_data.question' => __("errors.api.answer.missing_question"),
            ]);
        }
        if (empty($parsed['fields']) || !is_array($parsed['fields'])) {
            throw ValidationException::withMessages([
                'answer_data.fields' => __("errors.api.answer.missing_fields"),
            ]);
        }

        // 例: fields.*.field_id & fields.*.user_answer の存在チェック
        foreach ($parsed['fields'] as $idx => $field) {
            if (empty($field['field_id'])) {
                throw ValidationException::withMessages([
                    "answer_data.fields.{$idx}.field_id" => __("errors.api.answer.field_id_required"),
                ]);
            }
            if (! array_key_exists('user_answer', $field)) {
                throw ValidationException::withMessages([
                    "answer_data.fields.{$idx}.user_answer" => __("errors.api.answer.user_answer_required"),
                ]);
            }
        }

        // OKなら返す
        return $parsed;
    }

    /**
     * LLM評価用のAPI呼び出し
     */
    private function callLLMEvaluationApi(array $answerData, Question $question, UserQuestion $userQuestion): array
    {
        $responseFormat = $question->evaluation_response_format;
        $learningRequirement = $question->learning_requirement_json;
        $userAnswerJson = json_encode($answerData, JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT);
        $promptId = $question->llm_evaluation_prompt_number;
        $metadata = $userQuestion->metadata;


        $prompt = $this->buildPrompt($promptId, $userAnswerJson, $responseFormat, $learningRequirement, $metadata);

        $userQuestion->prompt_for_evaluation = $prompt;
        $userQuestion->save();

//        $model = 'gpt-4o-mini';
        $model = 'chatgpt-4o-latest';
//        $model = 'o3-mini';
        $response = Http::withToken(config('services.openai.api_key'))
            ->post('https://api.openai.com/v1/chat/completions', [
                'model' => $model,
                'messages' => [
                    [
                        'role' => 'system',
                        'content' => 'You are a helpful assistant. Return your answer in valid JSON format only, with no extra text.'
                    ],
                    [
                        'role' => 'assistant',
                        'content' => $responseFormat
                    ],
                    [
                        'role' => 'user',
                        'content' => $prompt
                    ]
                ],
                'response_format' => [
                  'type' => 'json_object'
                ],
                'temperature' => 0.0,
            ]);

        $responseBody = $response->json();

        $rawContent = data_get($responseBody, 'choices.0.message.content');

        $parsed = json_decode($rawContent, true);

        return $parsed ?? [];
    }

    /**
     * CODE評価 (evaluation_method=2) 用のロジック例
     */
    private function evaluateByCode(Question $question, array $answerData): bool
    {
        // 例: fields[0].user_answer が "32" なら正解
        $firstAnswer = data_get($answerData, 'fields.0.user_answer');
        return ($firstAnswer === "32");
    }

    /**
     * 次の問題( status=NOT_START )を order 昇順 で1件取得
     * なければ null
     */
    private function findNextQuestion(string $userQuestionSetId): ?UserQuestion
    {
        // user_questions と question_set_questions をJOINして
        // question_set_questions.order が最小の NOT_START を取得
        $row = DB::table('question_set_questions as qsq')
            ->join('user_questions as uq', 'uq.question_id', '=', 'qsq.question_id')
            ->where('uq.user_question_set_id', $userQuestionSetId)
            ->where('uq.status', UserQuestionStatus::NOT_START->value)
            ->orderBy('qsq.order', 'asc')
            ->select('uq.*')
            ->first();

        return $row ? (new UserQuestion)->newFromBuilder($row) : null;
    }

    /**
     * 回答後のレスポンス用 DTO を組み立てる
     */
    private function buildAnswerCheckDto(
        UserQuestion $userQuestion,
        Question $question,
        ?UserQuestion $nextUserQuestion,
        array $content,
    ): AnswerCheckDto {
        // ここでは既存の AnswerCheckDto::$content
        // 「現在の問題」と「次の問題」の情報を簡易的にまとめて返す例
        $nextUserQuestionId = null;

        if (!empty($nextUserQuestion)) {
            $nextUserQuestionId = $nextUserQuestion->id;
        }

        return new AnswerCheckDto(
            content: $content,
            next_user_question_id: $nextUserQuestionId
        );
    }

    public function buildPrompt(int $promptId, string $userAnswerJson, string $responseFormat, string $learningRequirement, string $metadata): string
    {
        $promptPath = resource_path("prompts/evaluation/{$promptId}.txt");
        if (! file_exists($promptPath)) {
            throw new \RuntimeException("Prompt file not found: {$promptPath}");
        }

        $template = file_get_contents($promptPath);

        $replaced = str_replace(
            [
                '{$userAnswerJson}',
                '{$responseFormat}',
                '{$learningRequirement}',
                '{$metadata}'
            ],
            [
                $userAnswerJson,
                $responseFormat,
                $learningRequirement,
                $metadata
            ],
            $template
        );

        return $replaced;
    }
}

```

--- QuestionJsonManageService
```php
<?php

namespace App\Services\Utils\Question;

use App\Enums\EvaluationCheckerMethod;
use App\Enums\EvaluationMethod;
use App\Enums\QuestionType;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\ValidationException;

/**
 * Class QuestionJsonManageService
 *
 * 【概要】
 * - GitHubリポジトリ等からインポートされる問題JSONをバリデーション＆加工するサービスクラス
 * - question_type が増えた場合にもルールを簡単に追加・削除できるように設計
 * - バリデーション違反で処理停止せず、その問題だけスキップ（ValidationException）できる
 *
 * 【今回の修正内容・実装仕様】
 * 1. トップレベルの question_text, explanation, background を削除
 *    → 代わりに metadata.question_text, metadata.explanation, metadata.background で必須チェック
 * 2. evaluation_method="CODE" 時、response_format.* が metadata の該当項目と一致することをチェック
 * 3. evaluation_method="LLM" 時、"text" 固定であることをチェック & fields が必須
 * 4. fields[*].field_explanation => 空文字禁止
 * 5. question_type が FILL_IN_THE_BLANK, SCENARIO など将来的に追加されても拡張しやすい
 * 6. エラーメッセージは日本語でわかりやすく
 * 7. バリデーション違反時に ValidationException をthrow → 呼び出し元はスキップ可能
 */
class QuestionJsonManageService
{
    /**
     * 言語定数 (アプリケーション全体で共通利用)
     */
    public const LANGUAGES = ['ja', 'en'];

    /**
     * input_format.type の定数
     */
    public const INPUT_FORMAT_TYPES = [
        'fixed',
        'custom',
    ];

    /**
     * input_format.fields.type / evaluation_spec.response_format.fields.user_answer
     * / metadata.input_format.fields.user_answer の定数 ("number"のみ)
     */
    public const FIELD_TYPE = [
        'number',
    ];

    /**
     * question_components.type の定数
     */
    public const COMPONENT_TYPES = [
        'text',
        'image',
        'movie',
        'blank',
    ];

    //============================================================
    // 問題JSONのバリデーション
    //============================================================
    public function validateQuestionJson(array $json): array
    {
        // 変更：トップレベルの question_text/explanation/background は削除

        // 1) トップレベル共通ルール
        $validator = Validator::make($json, $this->getTopLevelRules(), $this->messages());

        // 2) after()で追加の詳細チェック（DB存在, CODE/LLM分岐, metadata）
        $validator->after(function ($v) use ($json) {
            $this->validateLevelGradeDifficulty($v, $json);
            $this->validateSkills($v, $json);
            $this->validateEvaluationSpec($v, $json);
            $this->validateMetadata($v, $json);
        });

        // 3) 実行 (NGなら ValidationException)
        return $validator->validate();
    }

    //============================================================
    // ユーザー回答JSONのバリデーション
    //============================================================
    /**
     *
     * 【仕様】
     *  - metadata内の input_format との整合をチェック
     *  - input_format.type="fixed" の場合、ユーザー回答のfields数が metadataのfields数と一致するか
     *  - input_format.type="custom" の場合、fields数は不問だが、1件1件のfield_id, attribute, user_answerの型をチェック
     *  - attribute='number'のとき user_answer は数値型 など
     *  - question_type=FILL_IN_THE_BLANK の場合のみ実装
     *  - TODO: 将来的に question_type が増えたら case分岐等で拡張（現在はFILL_IN_THE_BLANKのみ）
     *
     * @param array $answerData 例: {"fields":[{"field_id":"f_1","attribute":"number","user_answer":4},...]}
     * @param array $metadata   user_question.metadata の配列
     * @throws ValidationException
     */
    public function validateUserAnswer(array $answerData, array $metadata): void
    {
        // 1) question_type 確認
        $qt = $metadata['question_type'] ?? null;
        if ($qt !== 'FILL_IN_THE_BLANK') {
            // TODO 多言語対応: 'このquestion_typeはまだ回答チェックを実装していません。'
            return;
        }

        // 2) input_format
        $inFmt = $metadata['input_format'] ?? [];
        if (!is_array($inFmt)) {
            // TODO 多言語
            throw ValidationException::withMessages([
                'metadata.input_format' => "metadata.input_formatが存在しません。"
            ]);
        }

        // 3) fields: metadata側
        $metaFields = $inFmt['fields'] ?? [];
        if (!is_array($metaFields)) {
            // TODO 多言語
            throw ValidationException::withMessages([
                'metadata.input_format.fields' => "metadata.input_format.fields が配列ではありません。"
            ]);
        }

        $type = $inFmt['type'] ?? '';
        if (!in_array($type, ['fixed','custom'], true)) {
            // TODO 多言語
            throw ValidationException::withMessages([
                'metadata.input_format.type' => "input_format.type='{$type}' は未対応です。"
            ]);
        }

        // 4) ユーザー回答fields
        $answerFields = $answerData['fields'] ?? null;
        if (!is_array($answerFields)) {
            // TODO 多言語
            throw ValidationException::withMessages([
                'fields' => "回答JSONの 'fields' が配列ではありません。"
            ]);
        }

        // 5) "fixed" の場合、数が一致するかチェック
        if ($type === 'fixed') {
            $countMeta = count($metaFields);
            $countAns  = count($answerFields);
            if ($countMeta !== $countAns) {
                // TODO 多言語
                throw ValidationException::withMessages([
                    'fields' => "input_format.type=fixed ですが、fields数が一致しません。(metadata={$countMeta}, answer={$countAns})"
                ]);
            }
        }

        // 6) 動的に field_id ごとにチェック
        //   - attribute が "number" なら user_answer は数値
        //   - "custom"の場合は、回答側に多い/少ないfieldsがあっても許容
        //
        //   メタデータfieldsを field_id -> [ 'attribute'=>..., 'user_answer'=>... ] の連想配列にしておく
        $metaFieldMap = [];
        foreach ($metaFields as $mf) {
            $fid = $mf['field_id'] ?? null;
            if ($fid) {
                $metaFieldMap[$fid] = $mf;
            }
        }

        // 回答fieldsをループ
        foreach ($answerFields as $idx => $af) {
            // field_id
            $fid = $af['field_id'] ?? '';
            if (!$fid) {
                // TODO 多言語
                throw ValidationException::withMessages([
                    "fields.{$idx}.field_id" => "field_id は必須です。"
                ]);
            }
            $attribute = $af['attribute'] ?? null;
            $userAns   = $af['user_answer'] ?? null;

            if (!$attribute) {
                // TODO 多言語
                throw ValidationException::withMessages([
                    "fields.{$idx}.attribute" => "attribute が存在しません。"
                ]);
            }

            // fixed: メタデータにfidが無い場合はエラー
            // custom: メタデータにfidが無い場合も許容?
            //   今回の仕様では「customなら追加自由」とあるが、ここでは conservativeに
            //   customの場合でも、少なくとも attribute='number'なら user_answer数値, etc というルールを守る
            //   "fields"追加が自由→ ここでは attribute='number' であれば user_answerを数値に など
            //   (メタデータ上に無いfield_idであっても一応OKにする)
            $metaDefinition = $metaFieldMap[$fid] ?? null;
            if ($type==='fixed' && !$metaDefinition) {
                // TODO 多言語
                throw ValidationException::withMessages([
                    "fields.{$idx}.field_id" => "metadataに存在しない field_id='{$fid}' です。"
                ]);
            }

            // attribute='number' の場合
            if ($attribute==='number') {
                // user_answer が数値型か
                if (!is_numeric($userAns)) {
                    // TODO 多言語
                    throw ValidationException::withMessages([
                        "fields.{$idx}.user_answer" => "attribute='number' の場合 user_answer には数値が必要です。"
                    ]);
                }
            } else {
                // 現状 'number'しか無い想定
                throw ValidationException::withMessages([
                    "fields.{$idx}.attribute" => "attribute='{$attribute}' は無効です。('number'のみ対応)"
                ]);
            }
        }

        // 特にエラーが無ければOK
    }
    /**
     * トップレベルの共通ルール
     */
    private function getTopLevelRules(): array
    {
        return [
            // 基本必須
            'order'         => ['required','integer'],
            'id'            => ['required','string'],
            'level_id'      => ['required','string'],
            'grade_id'      => ['required','string'],
            'difficulty_id' => ['required','string'],
            'version'       => ['required','regex:/^\d+\.\d+\.\d+$/'],
            'status'        => ['required','string'],
            'generated_by_llm' => ['required','boolean'],
            'created_at'    => ['required','date_format:Y-m-d H:i:s'],
            'updated_at'    => ['required','date_format:Y-m-d H:i:s'],

            // 変更： question_text/explanation/background をここで削除

            // skills => 必須
            'skills' => ['required','array'],

            // learning_requirements => 必須
            'learning_requirements'                               => ['required','array'],
            'learning_requirements.*.learning_subject'            => ['required','string'],
            'learning_requirements.*.learning_no'                 => ['required','integer'],
            'learning_requirements.*.learning_requirement'        => ['required','string'],
            'learning_requirements.*.learning_required_competency'=> ['required','string'],
            'learning_requirements.*.learning_background'         => ['required','string'],
            'learning_requirements.*.learning_category'           => ['required','string'],
            'learning_requirements.*.learning_grade_level'        => ['required','string'],
            'learning_requirements.*.learning_url'                => ['sometimes','url'],

            // evaluation_spec => 必須
            'evaluation_spec'                   => ['required','array'],
            'evaluation_spec.evaluation_method' => ['required','string'],

            // metadata => question_type / question_text / explanation / background / input_format
            'metadata'                              => ['required','array'],
            'metadata.question_type'                => ['required'],
            // 変更： question_text, explanation, background の必須チェックをmetadataへ移動
            'metadata.question_text'                => ['required','array'],
            'metadata.question_text.ja'             => ['required','string'],
            'metadata.question_text.en'             => ['required','string'],
            'metadata.explanation'                  => ['required','array'],
            'metadata.explanation.ja'               => ['required','string'],
            'metadata.explanation.en'               => ['required','string'],
            'metadata.background'                   => ['required','array'],
            'metadata.background.ja'                => ['required','string'],
            'metadata.background.en'                => ['required','string'],

            'metadata.question'                     => ['required','array'],
            'metadata.question.ja'                  => ['required','string'],
            'metadata.question.en'                  => ['required','string'],

            'metadata.input_format'                 => ['required','array'],
            'metadata.input_format.type'            => ['required','string','in:fixed,custom'],
            'metadata.input_format.fields'          => ['required','array'],
            'metadata.input_format.question_components' => ['required','array'],
        ];
    }

    /**
     * 日本語エラーメッセージ
     */
    private function messages(): array
    {
        return [
            'required'    => ':attribute は必須項目です。',
            'integer'     => ':attribute は数値を指定してください。',
            'string'      => ':attribute は文字列である必要があります。',
            'boolean'     => ':attribute は true/false を指定してください。',
            'date_format' => ':attribute は :format 形式で指定してください。',
            'regex'       => ':attribute の形式が不正です。(例: 1.0.0)',
            'array'       => ':attribute は配列である必要があります。',
            'in'          => ':attribute に不正な値が指定されました( :values )。',
            'url'         => ':attribute は有効なURL形式で指定してください。',
        ];
    }

    /**
     * level_id,grade_id,difficulty_id が DBにあるかチェック
     */
    private function validateLevelGradeDifficulty($validator, array $json)
    {
        $levelId = $json['level_id'] ?? null;
        $gradeId = $json['grade_id'] ?? null;
        $diffId  = $json['difficulty_id'] ?? null;

        if ($levelId) {
            $exists = \DB::table('levels')->where('json_id', $levelId)->exists();
            if (!$exists) {
                $validator->errors()->add('level_id', "指定された level_id='{$levelId}' はDBに存在しません。");
            }
        }
        if ($gradeId) {
            $exists = \DB::table('grades')->where('json_id', $gradeId)->exists();
            if (!$exists) {
                $validator->errors()->add('grade_id', "指定された grade_id='{$gradeId}' はDBに存在しません。");
            }
        }
        if ($diffId) {
            $exists = \DB::table('difficulties')->where('json_id', $diffId)->exists();
            if (!$exists) {
                $validator->errors()->add('difficulty_id', "指定された difficulty_id='{$diffId}' はDBに存在しません。");
            }
        }
    }

    /**
     * skills => skill_idがDBにあるか、nameがdisplay_nameと一致するか
     */
    private function validateSkills($validator, array $json)
    {
        $skills = $json['skills'] ?? [];
        if (!is_array($skills)) {
            return;
        }

        foreach ($skills as $idx => $sk) {
            $sid   = $sk['skill_id'] ?? null;
            $sname = $sk['name']     ?? null;
            if (!$sid || !$sname) {
                continue;
            }
            $row = \DB::table('skills')->where('json_id', $sid)->first();
            if (!$row) {
                $validator->errors()->add("skills.{$idx}.skill_id",
                    "skill_id='{$sid}' はDBに存在しません。");
                continue;
            }
            if ($row->display_name !== $sname) {
                $validator->errors()->add("skills.{$idx}.name",
                    "skill_id='{$sid}' の display_name と name='{$sname}' が一致しません。");
            }
        }
    }

    /**
     * evaluation_spec => evaluation_method=CODE or LLM
     */
    private function validateEvaluationSpec($validator, array $json)
    {
        $eval = $json['evaluation_spec'] ?? [];
        $methodRaw = $eval['evaluation_method'] ?? null;
        if (!$methodRaw) {
            return;
        }

        // enumに存在するか
        try {
            $method = EvaluationMethod::fromString($methodRaw);
        } catch (\InvalidArgumentException) {
            $validator->errors()->add('evaluation_spec.evaluation_method',
                "evaluation_method='{$methodRaw}' は無効です (CODE/LLM)。");
            return;
        }

        if ($method === EvaluationMethod::CODE) {
            // checker_method 必須
            if (empty($eval['checker_method']) || !is_string($eval['checker_method'])) {
                $validator->errors()->add('evaluation_spec.checker_method',
                    "evaluation_method=CODE のため checker_method(文字列) が必須です。");
            } else {
                // enumチェック
                try {
                    EvaluationCheckerMethod::fromString($eval['checker_method']);
                } catch (\InvalidArgumentException) {
                    $validator->errors()->add('evaluation_spec.checker_method',
                        "checker_method='{$eval['checker_method']}' は未定義です。");
                }
            }

            // response_format => 必須
            if (!isset($eval['response_format']) || !is_array($eval['response_format'])) {
                $validator->errors()->add('evaluation_spec.response_format',
                    "evaluation_method=CODE のため response_format(オブジェクト) が必須です。");
            } else {
                $this->validateResponseFormatForCode($validator, $json, $eval['response_format']);
            }

        } elseif ($method === EvaluationMethod::LLM) {
            // llm_prompt_number 必須 + ファイル
            if (!isset($eval['llm_prompt_number']) || !is_numeric($eval['llm_prompt_number'])) {
                $validator->errors()->add('evaluation_spec.llm_prompt_number',
                    "evaluation_method=LLM のため llm_prompt_number(数値) が必須です。");
            } else {
                $path = resource_path("prompts/evaluation/{$eval['llm_prompt_number']}.txt");
                if (!file_exists($path)) {
                    $validator->errors()->add('evaluation_spec.llm_prompt_number',
                        "LLM promptファイルが見つかりません。(path={$path})");
                }
            }

            if (!isset($eval['response_format']) || !is_array($eval['response_format'])) {
                $validator->errors()->add('evaluation_spec.response_format',
                    "evaluation_method=LLM のため response_format(オブジェクト) が必須です。");
            } else {
                $this->validateResponseFormatForLlm($validator, $eval['response_format']);
            }
        }
    }

    // ======================================================================
    // CODE 用 response_format チェック
    // ======================================================================

    /**
     * CODE用 response_format を検証
     * - is_correct => "boolean"
     * - score => "number"
     * - question_text/explanation => 「metadata.question_text」「metadata.explanation」と一致
     * - question => metadata.question と一致
     * - fields => 必須ではないが、あればバリデーション
     */
    private function validateResponseFormatForCode($validator, array $json, array $resp)
    {
        // is_correct => "boolean"
        if (($resp['is_correct'] ?? '') !== 'boolean') {
            $validator->errors()->add('evaluation_spec.response_format.is_correct',
                "CODE: is_correct は 'boolean' のみ有効です。");
        }

        // score => "number"
        if (($resp['score'] ?? '') !== 'number') {
            $validator->errors()->add('evaluation_spec.response_format.score',
                "CODE: score は 'number' のみ有効です。");
        }

        // 変更： question_text ⇒ metadata.question_text と一致
        if (empty($resp['question_text']) || !is_array($resp['question_text'])) {
            $validator->errors()->add('evaluation_spec.response_format.question_text',
                "CODE: question_text(オブジェクト) が必須です。");
        } else {
            $this->validateResponseFormatQuestionTextForCode($validator, $json, $resp['question_text']);
        }

        // 変更： explanation ⇒ metadata.explanation と一致
        if (empty($resp['explanation']) || !is_array($resp['explanation'])) {
            $validator->errors()->add('evaluation_spec.response_format.explanation',
                "CODE: explanation(オブジェクト) が必須です。");
        } else {
            $this->validateResponseFormatExplanationForCode($validator, $json, $resp['explanation']);
        }

        // question => metadata.question と一致
        if (empty($resp['question']) || !is_array($resp['question'])) {
            $validator->errors()->add('evaluation_spec.response_format.question',
                "CODE: question(オブジェクト) が必須です。");
        } else {
            $this->validateResponseFormatQuestionForCode($validator, $json, $resp['question']);
        }

        // fields => あれば検証
        if (!empty($resp['fields']) && is_array($resp['fields'])) {
            foreach ($resp['fields'] as $idx => $f) {
                $this->validateResponseFieldForCode($validator, $f, $idx);
            }
        }
    }

    /**
     * question_text => metadata.question_text と一致
     */
    private function validateResponseFormatQuestionTextForCode($validator, array $json, array $obj)
    {
        // 変更：トップレベルから metadataへ移動
        foreach (self::LANGUAGES as $lang) {
            $expected = $json['metadata']['question_text'][$lang] ?? '';
            $actual   = $obj[$lang] ?? '';
            if ($actual !== $expected) {
                $validator->errors()->add("evaluation_spec.response_format.question_text.{$lang}",
                    "CODE: question_text.{$lang} は metadata.question_text.{$lang} と一致する必要があります( expected='{$expected}' )。");
            }
        }
    }

    /**
     * explanation => metadata.explanation と一致
     */
    private function validateResponseFormatExplanationForCode($validator, array $json, array $obj)
    {
        // 変更：トップレベル から metadata.explanation へ
        foreach (self::LANGUAGES as $lang) {
            $expected = $json['metadata']['explanation'][$lang] ?? '';
            $actual   = $obj[$lang] ?? '';
            if ($actual !== $expected) {
                $validator->errors()->add("evaluation_spec.response_format.explanation.{$lang}",
                    "CODE: explanation.{$lang} は metadata.explanation.{$lang} と一致する必要があります( expected='{$expected}' )。");
            }
        }
    }

    /**
     * question => metadata.question と一致
     */
    private function validateResponseFormatQuestionForCode($validator, array $json, array $obj)
    {
        $metaQ = $json['metadata']['question'] ?? [];
        foreach (self::LANGUAGES as $lang) {
            $expected = $metaQ[$lang] ?? '';
            $actual   = $obj[$lang] ?? '';
            if ($actual !== $expected) {
                $validator->errors()->add("evaluation_spec.response_format.question.{$lang}",
                    "CODE: question.{$lang} は metadata.question.{$lang} と一致する必要があります( expected='{$expected}' )。");
            }
        }
    }

    /**
     * fields => CODE用 (存在すればチェック)
     * - is_correct => "boolean" / user_answer => "number"? / collect_answer => 数値?
     * - field_explanation => 全言語で空文字禁止
     */
    private function validateResponseFieldForCode($validator, array $field, int $idx)
    {
        // field_id
        if (empty($field['field_id']) || !is_string($field['field_id'])) {
            $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.field_id",
                "CODE: field_id は必須の文字列です。");
        }

        // user_answer => "number"のみ
        if (!empty($field['user_answer'])) {
            if (!in_array($field['user_answer'], self::FIELD_TYPE, true)) {
                $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.user_answer",
                    "CODE: user_answer='{$field['user_answer']}' は無効です。(例:'number')");
            }
        }

        // is_correct => "boolean"
        if (!empty($field['is_correct']) && $field['is_correct'] !== 'boolean') {
            $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.is_correct",
                "CODE: is_correct は 'boolean' のみ有効です。");
        }

        // collect_answer => 数値か
        if (($field['user_answer'] ?? '') === 'number') {
            if (!isset($field['collect_answer']) || !is_numeric($field['collect_answer'])) {
                $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.collect_answer",
                    "CODE: collect_answer は数値が必要です (user_answer='number')。");
            }
        }

        // field_explanation => LANGUAGES すべてで空文字禁止
        if (!empty($field['field_explanation']) && is_array($field['field_explanation'])) {
            foreach (self::LANGUAGES as $lang) {
                if (!isset($field['field_explanation'][$lang])
                    || !is_string($field['field_explanation'][$lang])
                    || trim($field['field_explanation'][$lang]) === ''
                ) {
                    $validator->errors()->add(
                        "evaluation_spec.response_format.fields.{$idx}.field_explanation.{$lang}",
                        "CODE: field_explanation.{$lang} は必須の文字列で、空文字は許可されません。"
                    );
                }
            }
        }
    }

    // ======================================================================
    // LLM用 response_format チェック
    // ======================================================================

    /**
     * LLM用 response_format を検証
     * - is_correct => "boolean", score => "number"
     * - question_text/explanation/question => langごとに 'text'
     * - fields => user_answer='number', collect_answer=数値, field_explanation=空文字禁止
     */
    private function validateResponseFormatForLlm($validator, array $resp)
    {
        // is_correct => "boolean"
        if (($resp['is_correct'] ?? '') !== 'boolean') {
            $validator->errors()->add('evaluation_spec.response_format.is_correct',
                "LLM: is_correct は 'boolean' のみ有効です。");
        }

        // score => "number"
        if (($resp['score'] ?? '') !== 'number') {
            $validator->errors()->add('evaluation_spec.response_format.score',
                "LLM: score は 'number' のみ有効です。");
        }

        // question_text => langごと 'text'
        if (empty($resp['question_text']) || !is_array($resp['question_text'])) {
            $validator->errors()->add('evaluation_spec.response_format.question_text',
                "LLM: question_text(オブジェクト) は必須です。");
        } else {
            foreach (self::LANGUAGES as $lang) {
                if (!isset($resp['question_text'][$lang])) {
                    $validator->errors()->add("evaluation_spec.response_format.question_text.{$lang}",
                        "LLM: question_text.{$lang} がありません。");
                } else {
                    if ($resp['question_text'][$lang] !== 'text') {
                        $validator->errors()->add("evaluation_spec.response_format.question_text.{$lang}",
                            "LLM: question_text.{$lang} は 'text' のみ有効です。"
                        );
                    }
                }
            }
        }

        // explanation => langごと 'text'
        if (empty($resp['explanation']) || !is_array($resp['explanation'])) {
            $validator->errors()->add('evaluation_spec.response_format.explanation',
                "LLM: explanation(オブジェクト) は必須です。");
        } else {
            foreach (self::LANGUAGES as $lang) {
                if (!isset($resp['explanation'][$lang])) {
                    $validator->errors()->add("evaluation_spec.response_format.explanation.{$lang}",
                        "LLM: explanation.{$lang} がありません。");
                } else {
                    if ($resp['explanation'][$lang] !== 'text') {
                        $validator->errors()->add("evaluation_spec.response_format.explanation.{$lang}",
                            "LLM: explanation.{$lang} は 'text' のみ有効です。"
                        );
                    }
                }
            }
        }

        // question => langごと 'text'
        if (empty($resp['question']) || !is_array($resp['question'])) {
            $validator->errors()->add('evaluation_spec.response_format.question',
                "LLM: question(オブジェクト) は必須です。");
        } else {
            foreach (self::LANGUAGES as $lang) {
                if (!isset($resp['question'][$lang])) {
                    $validator->errors()->add("evaluation_spec.response_format.question.{$lang}",
                        "LLM: question.{$lang} がありません。");
                } else {
                    if ($resp['question'][$lang] !== 'text') {
                        $validator->errors()->add("evaluation_spec.response_format.question.{$lang}",
                            "LLM: question.{$lang} は 'text' のみ有効です。"
                        );
                    }
                }
            }
        }

        // fields => 必須配列
        if (empty($resp['fields']) || !is_array($resp['fields'])) {
            $validator->errors()->add('evaluation_spec.response_format.fields',
                "LLM: fields(配列) は必須です。");
        } else {
            foreach ($resp['fields'] as $idx => $field) {
                $this->validateResponseFieldForLlm($validator, $field, $idx);
            }
        }
    }

    /**
     * LLM用 fields.* 検証
     * - field_id(文字列), user_answer="number", is_correct="boolean", collect_answer=数値, field_explanation=空文字禁止
     */
    private function validateResponseFieldForLlm($validator, array $field, int $idx)
    {
        // field_id
        if (empty($field['field_id']) || !is_string($field['field_id'])) {
            $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.field_id",
                "LLM: field_id は必須の文字列です。");
        }

        // user_answer => "number" のみ
        if (($field['user_answer'] ?? '') !== 'number') {
            $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.user_answer",
                "LLM: user_answer は 'number' のみ有効です。");
        }

        // is_correct => "boolean"
        if (($field['is_correct'] ?? '') !== 'boolean') {
            $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.is_correct",
                "LLM: is_correct は 'boolean' のみ有効です。");
        }

        // collect_answer => 数値が必要 (user_answer='number')
        if (($field['user_answer'] ?? '') === 'number') {
            if (!isset($field['collect_answer']) || !is_numeric($field['collect_answer'])) {
                $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.collect_answer",
                    "LLM: collect_answer は数値を指定してください (user_answer='number')。"
                );
            }
        }

        // field_explanation => 全言語で空文字禁止
        if (empty($field['field_explanation']) || !is_array($field['field_explanation'])) {
            $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.field_explanation",
                "LLM: field_explanation(オブジェクト) は必須です。");
        } else {
            foreach (self::LANGUAGES as $lang) {
                if (!isset($field['field_explanation'][$lang])
                    || !is_string($field['field_explanation'][$lang])
                    || trim($field['field_explanation'][$lang]) === ''
                ) {
                    $validator->errors()->add("evaluation_spec.response_format.fields.{$idx}.field_explanation.{$lang}",
                        "LLM: field_explanation.{$lang} は非空文字列が必須です。");
                }
            }
        }
    }

    // ======================================================================
    // metadata 検証
    // ======================================================================

    /**
     * metadata (question_type / question_text / explanation / background / input_format.*) の検証
     *
     * - question_type => Enum
     * - question_text, explanation, background => 各言語必須
     * - input_format.fields => attribute="number", user_answer="number"
     * - question_components => blank数=fields数
     */
    private function validateMetadata($validator, array $json)
    {
        $meta = $json['metadata'] ?? [];
        $qtRaw = $meta['question_type'] ?? null;

        // question_type => App\Enums\QuestionType に存在
        if ($qtRaw) {
            $str = (string)$qtRaw;
            try {
                QuestionType::fromString($str);
            } catch (\InvalidArgumentException) {
                $validator->errors()->add('metadata.question_type',
                    "question_type='{$str}' は未定義です。");
            }
        }

        // question_text, explanation, background は getTopLevelRulesで一部必須化済み => ここで特に追加ロジックは不要

        // input_format.fields => attribute='number', user_answer='number'
        $fieldsArr = $meta['input_format']['fields'] ?? [];
        if (is_array($fieldsArr)) {
            $fieldIds = [];
            foreach ($fieldsArr as $idx => $f) {
                // field_id => f_x
                if (empty($f['field_id']) || !preg_match('/^f_\d+$/', $f['field_id'])) {
                    $validator->errors()->add("metadata.input_format.fields.{$idx}.field_id",
                        "field_id='f_数字'形式が必須です。");
                }

                // 重複チェック
                if (in_array($f['field_id'] ?? '', $fieldIds, true)) {
                    $validator->errors()->add("metadata.input_format.fields.{$idx}.field_id",
                        "field_id='{$f['field_id']}' が重複しています。");
                }
                $fieldIds[] = $f['field_id'] ?? '';

                // attribute => 'number'
                if (!isset($f['attribute']) || !in_array($f['attribute'], self::FIELD_TYPE, true)) {
                    $validator->errors()->add("metadata.input_format.fields.{$idx}.attribute",
                        "attribute='{$f['attribute']}' は 'number' のみ有効です。");
                }

                // user_answer => "number" の文字列が必須
                if (!isset($f['user_answer']) || !is_string($f['user_answer'])) {
                    $validator->errors()->add("metadata.input_format.fields.{$idx}.user_answer",
                        "user_answer は必須の文字列です(例:'number')。");
                } else {
                    if (!in_array($f['user_answer'], self::FIELD_TYPE, true)) {
                        $validator->errors()->add("metadata.input_format.fields.{$idx}.user_answer",
                            "user_answer='{$f['user_answer']}' は 'number' のみ有効です。");
                    }
                }
            }
        }

        // question_components => blank数=fields数
        $comps = $meta['input_format']['question_components'] ?? [];
        if (is_array($comps)) {
            $blankCount = 0;
            $orders = [];
            foreach ($comps as $cidx => $comp) {
                $ctype = $comp['type'] ?? '';
                if (!in_array($ctype, self::COMPONENT_TYPES, true)) {
                    $validator->errors()->add("metadata.input_format.question_components.{$cidx}.type",
                        "不正なコンポーネントtype='{$ctype}'です。");
                }
                if ($ctype === 'blank') {
                    $blankCount++;
                    if (!isset($comp['field_id'])) {
                        $validator->errors()->add("metadata.input_format.question_components.{$cidx}.field_id",
                            "type=blank の場合 field_id が必須です。");
                    }
                } else {
                    // text,image,movie => content.{ja,en} 必須
                    if (empty($comp['content']) || !is_array($comp['content'])) {
                        $validator->errors()->add("metadata.input_format.question_components.{$cidx}.content",
                            "type='{$ctype}' の場合 content(オブジェクト) が必須です。");
                    } else {
                        foreach (self::LANGUAGES as $lang) {
                            if (!isset($comp['content'][$lang])) {
                                $validator->errors()->add(
                                    "metadata.input_format.question_components.{$cidx}.content.{$lang}",
                                    "content.{$lang} がありません。"
                                );
                            }
                        }
                    }
                }

                // order => 数値 + 重複
                if (!isset($comp['order']) || !is_numeric($comp['order'])) {
                    $validator->errors()->add("metadata.input_format.question_components.{$cidx}.order",
                        "order(数値) は必須です。");
                } else {
                    if (in_array($comp['order'], $orders, true)) {
                        $validator->errors()->add("metadata.input_format.question_components.{$cidx}.order",
                            "order='{$comp['order']}' が重複しています。");
                    }
                    $orders[] = $comp['order'];
                }
            }

            // blank数 と fields数
            $fieldsCount = count($fieldsArr);
            if ($blankCount !== $fieldsCount) {
                $validator->errors()->add("metadata.input_format.question_components",
                    "blank要素数({$blankCount}) と fields数({$fieldsCount}) が一致しません。");
            }
        }
    }

    // --------------------------------------------------------------------
    //  多言語メタデータをローカライズするサンプルメソッド（必要なら使用）
    // --------------------------------------------------------------------
    public function localizeMetadata(array $metadata): array
    {
        $locale = App::getLocale();

        // question_text => {ja:"...", en:"..."} => 1文言へ
        if (isset($metadata['question_text']) && is_array($metadata['question_text'])) {
            $metadata['question_text'] = $metadata['question_text'][$locale] ?? '';
        }
        if (isset($metadata['explanation']) && is_array($metadata['explanation'])) {
            $metadata['explanation']   = $metadata['explanation'][$locale] ?? '';
        }
        // TODO 暫定処理。background 学習の背景でありユーザーに見える必要はないのでレスポンスしない。ここで消す処理にするよりもmetadata用のResourceを用意してそちらでレスポンスを定義するべき
        if (isset($metadata['background']) && is_array($metadata['background'])) {
            unset($metadata['background']);
        }

//        if (isset($metadata['background']) && is_array($metadata['background'])) {
//            $metadata['background']    = $metadata['background'][$locale] ?? '';
//        }

        // question => type="text" => content を langごとの文字列に
        if (isset($metadata['question']) && is_array($metadata['question'])) {
            $metadata['question'] = $metadata['question'][$locale] ?? '';
        }

        // question_components => type="text" => content を langごとの文字列に
        if (isset($metadata['input_format']['question_components'])
            && is_array($metadata['input_format']['question_components'])) {
            foreach ($metadata['input_format']['question_components'] as $i => $comp) {
                if (($comp['type'] ?? '') === 'text'
                    && isset($comp['content'])
                    && is_array($comp['content'])) {
                    $metadata['input_format']['question_components'][$i]['content']
                        = $comp['content'][$locale] ?? '';
                }
            }
        }

        return $metadata;
    }
}
```
